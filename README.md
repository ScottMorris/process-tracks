# Process Tracks

This project is a simple set of scripts and programs to quickly batch process individual tracks out of a longer, combined audio file.

**Note**: This project has been tested on an Ubuntu 18.04 system.  The invocation of `ffmpeg` will be different for Windows based systems.

# Tools Used

- [.NET Core](https://dotnet.microsoft.com/download)
- [PowerShell Core 7+](https://github.com/PowerShell/PowerShell)
- [ffmpeg](https://ffmpeg.org/)
- [CommandLineParser](https://github.com/commandlineparser/commandline)

# Tracks

There are two steps to processing files using this project.

1. Converting a track list file into timecodes.
    
    This process is handled by the C# application. See Running - [C#](#c) below.

    The Timecodes are generated simply by taking the start of the next track and appending it as the end of the previous track.

1. Slicing up the combined audio file into separate tracks based on the timecodes.

    This process is handled by the PowerShell script. See Running - [PowerShell](#powershell) below.

## Track List

A track list is a list of tracks with a start offset time from the beginning of the combined audio track.  The format is pretty strict since the parser is really naïve and expects only one format.

This information should be in a plain old text file, eg. `tracklist.txt`.

Note the _single_ zero at the front of the time and the **–** (en dash) track separator.

```
0:00:00 Artist 1 – Best Song Ever (Club Mix)
0:05:07 Artist 2 feat. Cool Person X – Second to None is Still Not One
0:08:40 Artist 3 – Keep A-Rockn'
0:11:34 Artist 4 and the Moonlight Band – That was the best way (I liked it)

```

## Timecodes

Timecodes are what make this project tick.  The timecodes define the start and end of each track so that they can be extracted from the longer combined file.  The format of the timecodes file is generated by the C# application and looks like this,

```
00:00:00.00 00:05:07.00 rtist 1 – Best Song Ever (Club Mix)
00:05:07.00 00:08:40.00 Artist 2 feat. Cool Person X – Second to None is Still Not One
00:08:40.00 00:11:34.00 Artist 3 – Keep A-Rockn'
00:11:34.00 hh:mm:ss.ff Artist 4 and the Moonlight Band – That was the best way (I liked it)
```

What about the last track, how does it know when to end? Good question.  The last track is special case and it is handled, currently, by the user telling the generator how long the combined track is in total.  In the example above the `hh:mm:ss.ff` will be replaced by the total track time.

## Track Length

One piece of information that is required to generate the timecodes file is the total track length. This needs to be in the format `hh:mm:ss.ff`, eg. `00:14:32.56`.

A simple way to retrieve the total track length is to use `ffmpeg`,

```bash
$ ffmpeg -i combinedAudio.ext 2>&1 | grep "Duration" | cut -d ' ' -f 4 | sed s/,//
```

It will output the duration in the required `hh:mm:ss.ff` format.

```
00:14:32.56
```

# Program & Script

## C#

The C# application ingests the track list and converts it to a timecode file.  

For more on track lists see the [Track List](#track-list) section.

### Parameters
 
The following options are available,

```
    -v, --verbose         Set output to verbose messages.

    -t, --tracklist       Required. Tracklist to parse.

    -l, --track-length    Required. Length of track in hh:mm:ss.ff format.

    -o, --output          (Default: timecodes.txt) Output File

    -d, --dry-run         (Default: false) Perform a dry-run

    --help                Display this help screen.

    --version             Display version information.
```

### Running

```bash
$ dotnet run -- -v -t <path-to-tracklist> -l <length-of-track-in-hh:mm:ss.ff-format>
```

## PowerShell

To process the timecode file a simple PowerShell script is used to parse it and then invoke `ffmpeg` to slice the combined track into each individual file.  If the `album` parameter is present and not empty it will create a folder with the provided album name and output each file there.  Otherwise, it will create a folder called `splitOutput` and deposit each generated file there.

The script relies on `ffmpeg` to do the splitting and assigning of the metadata.  It copies the audio data as is and does not tanscode it.

Set metadata fields within output files, based off of [this list](https://wiki.multimedia.cx/index.php/FFmpeg_Metadata#QuickTime.2FMOV.2FMP4.2FM4A.2Fet_al.).

```powershell
-metadata track="$currentTrack" -metadata title="$title" -metadata artist="$artist" -metadata album_artist="$album_artist" -metadata album="$album" -metadata genre="$genre"
```

Copy audio stream and set the start and end times within the original combined audio file.

```powershell
-c:a copy -ss "$startTime" -to "$endTime"
```

### Parameters

```
-timecodeFileName - Path to Timecode file
-inputFile - Path to combined audio file
-album_artist - Metadata - Album Artist
-album - Metadata - Album
-album_art - Metadata - Album Art (Currently not supported)
-genre - Metadata - Genre
```

### Running

```powershell
PS> ./splitFile.ps1 -timecodeFileName ./timecodes.txt -inputFile "<path-to-audio-file>" -album_artist "<artist-name>" -album "<album-name>" -genre "<genre>"
```

# Helpful Resources
- [https://wiki.multimedia.cx/index.php/FFmpeg_Metadata#QuickTime.2FMOV.2FMP4.2FM4A.2Fet_al.](https://wiki.multimedia.cx/index.php/FFmpeg_Metadata#QuickTime.2FMOV.2FMP4.2FM4A.2Fet_al.)